# synchronized 锁升级

参考资料：[看完这篇恍然大悟，理解Java中的偏向锁，轻量级锁，重量级锁](https://zhuanlan.zhihu.com/p/571793506)

![看完这篇恍然大悟，理解Java中的偏向锁，轻量级锁，重量级锁](/imgs/JUC/v2-66ad9e336efa23c2ba1703c0224ce652_r.jpg)

高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。

## synchronized 锁优化的背景

用锁能够实现数据的安全性，但是会带来性能下降。
无锁能够基于线程并行提升程序性能，但会带来安全性下降。

### 锁的升级过程

无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

由对象头中的 MarkWord 根据锁标志位的不同而被复用及锁升级策略。

Java 的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态和与内核态之间来回切换，这种切换会带来性能的损耗。

为了减少获得锁和释放锁带来的性能消耗，引入了轻量级锁和偏向锁。

偏向锁： MarkWord 存储的是偏向的线程 ID;
轻量锁： MarkWord 存储的是指向线程栈中 LockRecord 的指针；
重量锁： MarkWord 存储的是指向堆中 monitor 对象的指针。

## 无锁

## 偏向锁

单线程竞争

当线程 A 第一次竞争到锁时，通过操作修改 MarkWord 中的偏向线程 ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步。

当一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。

大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

---

偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程将永远不需要进行同步。也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连 CAS 都不做了，直接提高程序性能。

锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。那么只需要在锁第一次被拥有的时候记录下偏向线程ID。这样偏向线程就一直持有着锁（后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接会去检查锁的MarkWord里面是不是放的自己的线程ID）。

- **如果相等**，表示还是由这个线程来持有锁，那么这个线程就不需要再做同步操作，即可以再次进入同步代码块。

- **如果不相等**，表示当前的锁对象已经被其他线程抢占了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程ID；
  - **竞争成功**，表示抢锁成功，MarkWord里面更新为新线程ID，锁不会升级，仍为偏向锁；
  - **竞争失败**，这时可能需要升级为轻量级锁，才能保证线程间公平竞争锁。

> 注意，偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。

---

-XX:+UseBiasedLocking 默认启用偏向锁。

-XX:BiasedLockingStartupDelay=4000 偏向锁启用延迟默认4000毫秒。

如果确定锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking，那么默认会进入轻量级锁。

### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行）。

- 当有另外一个线程逐步竞争锁的时候，就不能再使用偏向锁，要将锁升级为轻量级锁。
- 竞争线程尝试CAS更新对象头失败，会等待到全局安全点撤销偏向锁。
- 撤销。

1. 第一个线程正在执行synchronized方法（处于同步代码块），他还没执行完，其他线程来抢夺，该偏向锁就会被撤销并出现锁升级。此轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码块，而正在竞争的线程会进入自旋等待获得该轻量级锁。
2. 第一个线程执行完成synchronized方法（退出同步代码块），则将对象头设置为无锁状态并撤销偏向锁，重新开始偏向。

#### 偏向锁撤销过程

竞争线程CAS更新对象头失败 -> 等待全局安全点 -> 暂停原持有偏向锁线程 -> 检查偏向锁线程是否处于同步代码块 ->

1. -> 处于同步代码块 -> 将锁升级为轻量级锁 ->
2. -> 退出同步代码块 -> 置为无锁状态（偏向锁位0，锁标记01） ->

-> 唤醒原持有偏向锁线程 -> 继续执行synchronized方法。

| | 是否偏向锁 | 锁标记位 |
| ---- | ---- | ---- |
| 无锁 | 0 | 01 |
| 偏向锁 | 1 | 01 |
| 轻量级锁 | - | 00 |
| 重量级锁 | - | 10 |

JDK15取消并逐步废弃偏向锁，JDK17默认关闭偏向锁。

## 轻量级锁

存在多线程竞争，但同时只有一个线程竞争，即不存在激烈的锁竞争情况，也就没有线程阻塞。

有线程来竞争锁，但获取锁的冲突时间很短。

本质就是自旋锁CAS。

轻量级锁是为了线程近乎交替执行同步代码块时提高性能。

主要目的：在没有多线程竞争的前提下，通过CAS减少传统的重量级锁使用操作系统互斥量产生的性能消耗。先自旋，不行再升级。

升级时机：当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁。
