# $JMM$

Java内存模型（Java Memory Model，JMM）是Java虚拟机规范中所定义的一组规则，它用于控制Java程序中各个变量（包括实例变量和静态变量）的访问方式，以及提供一些保证（如原子性、可见性和有序性）。JMM定义了主内存和每个线程的工作内存，并规定了线程对主内存的读写操作必须经过工作内存，从而实现了线程之间的隔离。JMM还定义了各种内存屏障指令，用于确保内存操作的顺序性和原子性。

因为有多级缓存，CPU并不是直接操作内存，而是把内存的数据读到缓存，而内存的读和写操作的时候就会造成不一致。

JVM规范试图定义一种Java内存模型（JMM），来屏蔽掉各种硬件和操作系统的内存访问差异，从而确保Java程序在各种平台下都能达到一致的内存访问效果。

## JMM三大特性

### 1. 可见性

当一个线程修改了共享变量的值，其他线程能够立即看到修改后的值。

JMM规定所有共享变量都存储在主内存中，每个线程还有自己的工作内存，工作内存中存储了该线程使用到的共享变量的副本。线程对共享变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

#### 使用volatile关键字

当一个变量被volatile关键字修饰时，其他线程对该变量进行了修改后，会导致当前线程在工作内存中的变量副本失效，必须从主内存中再次获取，当前线程修改工作内存中的变量后，同时也会立刻将其修改刷新到主内存中。

#### 使用synchronized关键字

synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法或者代码块，并且确保在锁释放之前，会把变量的修改刷新到主内存中。

#### 使用Lock相关的工具类

Lock相关的工具类的lock方法能够保证同一时刻只有一个线程获得锁，然后执行同步代码块，并且确保执行Lock相关的工具类的unlock方法在之前，会把变量的修改刷新到主内存中。

### 2. 原子性

原子性是指一个操作是不可中断的，即要么全部执行成功，要么全部执行失败。

系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现脏读。

在Java内存模型中，只保证了对基本数据类型的读取和赋值操作是原子性操作。如果想保证多个操作的原子性，可以使用 `synchronized` 关键字或者 `Lock` 相关的工具类。如果想要使int、long等类型的自增操作具有原子性，可以用java.util.concurrent.atomic包下的工具类，如： `AtomicInteger` 、 `AtomicLong` 等。另外需要注意的是， `volatile` 关键字不具有保证原子性的语义。

### 3. 有序性

有序性是指程序执行的顺序按照代码的顺序来执行。但是由于指令重排的存在，实际的执行顺序有可能与代码顺序不一致。

JVM能够根据处理器特性（多级缓存系统，多核处理器等），适当的对机器指令重新排序，使机器指令能更符合CPU的执行特点，以达到性能优化。

指令重排可以保证串行语义一致，但没有义务保证多线程之间语义一致，也就可能产生脏读。
