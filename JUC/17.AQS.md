# AQS

AQS，全称是 AbstractQueuedSynchronizer，中文译为抽象队列式同步器。

是用来实现锁或者其他同步器组件的公共基础部分的抽象实现，是重量级基础框架及JUC体系的基石，主要用于解决锁分配给谁的问题。

整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型的成员变量表示持有锁状态。

AQS中的队列是CLH变体的虚拟双向队列FIFO

> ReentrantLock、CountDownLatch、CyclicBarrier、ReentrantReadWriteLock、Semaphore

统一规范并简化了锁的实现，将其抽象出来屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等。是一切锁和同步组件实现的公共基础部分。

如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的节点对象（Node），通过CAS、自旋以及 `LockSupport.park()` 的方式，维护 `state` 变量的状态，使并发达到同步的效果。

AQS使用一个 `volatile` 的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS来完成对 `state` 的修改。

AQS的 `state` 标识资源的状态，Node的等待状态 `volatile int waitStatus` （取值为 `CANCELLED`, `SIGNAL`, `CONDITION`, `PROPAGATE` ）表示Node的等待状态，也就是等候区中其他线程的等待状态。

## Node:

| 模式 | 含义 |
| ---- | ---- |
| SHARED | 表示线程以共享的模式等待锁 |
| EXCLUSIVE | 表示线程正在以独占的方式等待锁 |

## waitStatus 取值:

| 枚举 | 含义 |
| ---- | ---- |
| 0 | 当一个Node被初始化的时候的默认值 |
| CANCELLED | 为1，表示线程获取锁的请求已经取消了 |
| CONDITION | 为-2，表示线程获取锁的请求已经取消了|
| PROPAGATE | 为-3，表示线程处在SHARED情况下，该字段才会使用 |
| SIGNAL | 为-1，表示线程已经准备好了，就等资源释放 |

## 公平锁和非公平锁

> `公平锁` 和 `非公平锁` 的区别在于，公平锁在 `tryAcquire` 获取同步状态时多了一个限制条件：hasQueuedProcessors()，用于加锁时判断等待队列中是否存在有效节点。

``` java
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }


        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```

公平锁：公平锁讲究先来后到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；
非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程苏醒后，不一定就是派头的这个线程获得锁，他还是需要参与竞争锁（存在线程竞争的情况下），后来的线程可能不讲武德插队夺锁了。