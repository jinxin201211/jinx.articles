# $LockSupport$

> java.util.concurrent.locks.LockSupport

## 线程等待和唤醒

1. Object.wait()和Object.notify()方法是基础的线程等待和唤醒机制。

2. JUC包中Condition.await()和Condition.signal()方法是更强大的线程等待和唤醒机制。

3. LockSupport.park()和LockSupport.unpark()方法是JDK8中新增的线程等待和唤醒机制。

## Object.wait()和Object.notify()

1. Object.wait()和Object.notify()方法必须在同步方法或同步块中调用，否则会抛出IllegalMonitorStateException异常。

2. 使用顺序上，必须要先调用Object.wait()方法，再调用Object.notify()方法。

## Condition.await()和Condition.signal()

1. Condition.await()和Condition.signal()方法必须要在锁块中调用，否则会抛出IllegalMonitorStateException异常。

2. 先Condition.await()，后Condition.signal()。

## LockSupport

LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。

LockSupport使用了一种名为Permit（许可）的概念来实现线程的阻塞和唤醒，每个线程都有一个Permit。与Semaphore不同，Permit不会累积，最多只有一个。

该类与每个使用他的线程关联一个Permit，如果Permit可用，将立即返回park，并在此过程中消费；否则可能会阻止。如果尚未提供许可，则致电unpark来获取许可。

LockSupport定义了一组公共静态方法，这些方法提供了在给定线程上执行各种操作。

LockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程。

LockSupport不需要先获得某个对象的锁，也不会抛出IllegalMonitorStateException异常。没有严格的顺序要求，park()可以在unpark()之前或之后调用，只需要park()和unpark()成对出现即可。

park()方法有两个重载版本：

```java
public static void park() 
public static void park(Object blocker) 
```

park()方法有两个作用：

1. 把当前线程包装成一个节点，放入CLH队列中，然后调用Unsafe.park()方法阻塞当前线程。
2. 清除线程中断状态。

unpark()方法也有两个重载版本：

```java
public static void unpark(Thread thread) 
public static void unpark(Thread thread, Object blockerObj) 
```

unpark()方法的作用是唤醒处于阻塞状态的指定线程。
