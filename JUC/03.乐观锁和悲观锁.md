# $乐观锁和悲观锁$

## 1.悲观锁

- 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读写锁等，都是在做操作之前先上锁。
- synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
- 悲观锁适合写操作非常多的场景，这样可以减少不必要的锁竞争。

## 2.乐观锁

- 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
- 最常采用的是CAS算法，Java原子类中的递增操作就采用的CAS算法来保证原子性。
- 乐观锁适用于读操作非常多的场景，这样可以提高吞吐量。

## 3.synchronized

- 一个对象内如果有多个synchronized方法，某一个时刻，只要一个线程去调用其中的一个synchronized方法了，其他的线程都只能等待，换句话说，synchronized关键字锁的是对象，而不是方法。
- sychronized不会阻塞非同步的代码（即非synchronized方法）的执行。
- 对于静态同步方法，锁的是这个类的Class对象；对于普通同步方法，锁的是这个方法所在的对象；对于同步代码块，锁的是Synchronized括号里配置的对象。

> 执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（不管正常非正常）时释放管程。在方法执行期间，执行线程独占管程，其他任何线程都无法再获得同一个管程。
  每一个对象天生带有一个管程。
