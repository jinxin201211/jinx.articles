# 乐观锁和悲观锁

## 1. 悲观锁

- 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读写锁等，都是在做操作之前先上锁。
- synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。
- 悲观锁适合写操作非常多的场景，这样可以减少不必要的锁竞争。

## 2. 乐观锁

- 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
- 最常采用的是 CAS 算法，Java 原子类中的递增操作就采用的 CAS 算法来保证原子性。
- 乐观锁适用于读操作非常多的场景，这样可以提高吞吐量。

## 3.synchronized

- 一个对象内如果有多个 synchronized 方法，某一个时刻，只要一个线程去调用其中的一个 synchronized 方法了，其他的线程都只能等待，换句话说，synchronized 关键字锁的是对象，而不是方法。
- sychronized 不会阻塞非同步的代码（即非 synchronized 方法）的执行。
- 对于静态同步方法，锁的是这个类的 Class 对象；对于普通同步方法，锁的是这个方法所在的对象；对于同步代码块，锁的是 synchronized 括号里配置的对象。

> 执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（不管正常非正常）时释放管程。在方法执行期间，执行线程独占管程，其他任何线程都无法再获得同一个管程。
  每一个对象天生带有一个管程。
