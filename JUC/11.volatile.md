# volatile

## volatile 内存语义

当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存中。同时，其他线程对应的本地内存都会失效。

当读一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，然后从主内存中读取共享变量。

## 内存屏障

内存屏障（也称为内存栅栏、屏障指令等，是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以执行此点之后的操作），避免代码重排序。内存屏障起始就是一种 JVM 指令，JMM 的重排规则会要求 Java 编译器在生成 JVM 指令时，插入特定的内存屏障指令，通过这些内存屏障指令，volatile 实现了 JMM 中的可见性和有序性（禁止重排），但不能保证原子性。

内存屏障之前的所有写操作都要写入主内存，内存屏障之后的所有读操作都能读取到该写操作的值（可见性）。

- 写屏障（Store Memory Barrier）: 告诉处理器写屏障之前将所有存储在缓存中的数据同步到主内存。也就是当看到 Store 屏障指令，就必须吧该指令之前的所有写入指令都执行完毕才能继续往下执行。
- 读屏障（Load Memory Barrier）: 告诉处理器读屏障之后的读操作，都在读屏障之后执行。也就是在 Load 屏障指令之后就能保证后面的读取数据指令一定能读取到最新的数据。

| 屏障类型 | 指令示例 | 说明 |
| :-----: | ------- | ---- |
| LoadLoad | Load1;LoadLoad;Load2 | 保证 Load1 的读取操作在 Load2 及其后续操作之前执行 |
| StoreStore | Store1;StoreStore;Store2 | 在 Store2 及其后的写操作执行之前，确保 Store1 的写操作已经刷新到主内存中 |
| LoadStore | Load1;LoadStore;Store2 | 在 Store2 及其后的写操作执行之前，保证 Load1 的读操作已结束 |
| StoreLoad | Store1;StoreLoad;Load2 | 保证 Store1 的写操作已经刷新到主内存中之后，Load2 及其后的读操作才能执行 |

## volatile怎么保证有序性

禁止指令重排，通过内存屏障

| 第一个操作 | 第二个操作：普通读写 | 第二个操作：volatile 读 | 第二个操作：volatile 写 |
| --------- | ------------------ | --------------------- | --------------------- |
| **普通读写** | 可以重排 | 可以重排 | 禁止重排 |
| **volatile 读** | 禁止重排 | 禁止重排 | 禁止重排 |
| **volatile 写** | 可以重排 | 禁止重排 | 禁止重排 |

- 当第二个操作为 volatile 写时，不论第一个操作是什么，都不能重排。这保证了 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。
- 当第一个操作为 volatile 读时，不管第二个操作是什么，都不能重排。这保证了 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。
- 当第一个操作为 volatile 写时，第二个操作为 volatile 读时，不能重排。

读屏障，在每个 volatile 读操作之后插入一个 LoadLoad 屏障，在每个 volatile 读操作之后插入一个 LoadStore 屏障。
写屏障，在每个 volatile 写操作之前插入一个 StoreStore 屏障，在每个 volatile 写操作之前插入一个 StoreLoad 屏障。

## volatile怎么保证可见性

