# Happens-Before

## happens-before 总原则

解决并发编程中的可见性和有序性问题最直接的方法就是禁用 CPU 缓存和编译器的优化。但是，禁用这两者又会影响程序性能。于是我们要做的是按需禁用 CPU 缓存和编译器的优化。

Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器遵循一定的 Happens-Before 规则进行优化。

- 如果一个操作 happends-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在 happens-before 关系，并不意味着一定要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果与按照 happens-before 关系来执行的结果一致，那么这个重排序并不非法。

## happens-before 规则

- 程序次序规则（Program Order Rule）

在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。

在一个线程内，按照控制流顺序，如果操作 A 先行发生于操作 B，那么操作 A 所产生的影响对于操作 B 是可见的。

- 管程锁定规则（Monitor Lock Rule）

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

对于同一个锁，如果一个 unlock 操作先行发生于一个 lock 操作，那么该 unlock 操作所产生的影响对于该 lock 操作是可见的。

- volatile 变量规则（Volatile Variable Rule）

对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

对于同一个 volatile 变量，如果对于这个变量的写操作先行发生于这个变量的读操作，那么对于这个变量的写操作所产的影响对于这个变量的读操作是可见的。

- 线程启动规则（Thread Start Rule）

Thread 对象 start() 方法先行发生于此线程的每一个动作。

对于同一个 Thread 对象，该 Thread 对象的 start() 方法先行发生于此线程的每一个动作，也就是说对线程 start() 方法调用所产生的影响对于该该线程的每一个动作都是可见的。

- 线程终止规则（Thread Termination Rule）

线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法和 Thread.isAlive() 的返回值等手段检测线程是否已经终止执行。

对于一个线程，线程中发生的所有操作先行发生于对此线程的终止检测，也就是说线程中的所有操作所产生的影响对于调用线程 Thread.join() 方法或者 Thread.isAlive() 方法都是可见的。

- 线程中断规则（Thread Interruption Rule）

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。

对于同一个线程，对线程 interrupt() 方法的调用先行发生于该线程检测到中断事件的发生，也就是说线程 interrupt() 方法调用所产生的影响对于该线程检测到中断事件是可见的。

- 对象终结规则（Finalizer Rule）

一个对象的初始化完成（构造函数结束）先行发生于它的 finalize() 方法的开始。

对于同一个对象，它的构造方法执行结束先行发生于它的 finalize() 方法的开始，也就是说一个对象的构造方法结束所产生的影响，对于它的 finalize() 方法开始执行是可见的。

- 传递性（Transitivity）

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，则操作 A 先行发生于操作 C，也就说操作 A 所产生的所有影响对于操作 C 是可见的。
